<!DOCTYPE html><html>

<head>
<meta charset="utf-8">
<title>index</title>
<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
<style type="text/css">
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', monospace;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
</style>
</head>
<body>
<h1 id="toc_0">Grid Studies: Arduino</h1>

<p>By design the monome grid does nothing on it&#39;s own. You the user assign it purpose and meaning: instrument, experiment, tool, toy... choose your own adventure. This grid is <em>intended</em> to be reimagined. Here we set forth to impart some introductory knowledge: potential energy for radical creative freedom.</p>

<p>Arduino is an open-source electronics platform based on easy-to-use hardware and software. It is intended for anyone making interactive projects.</p>

<p>We&#39;ll be using the Ardunio&#39;s USB Host capabilities to run grid code without a computer, with easy access to physical hardware: sensors, motors, other actuators, wireless bits, everything. </p>

<h2 id="toc_1">Prerequisites</h2>

<p>If you&#39;re very new to Arduino, it will be very beneficial to work through the &#39;Getting Started&#39; section at Arduino.cc: <a href="http://arduino.cc/en/Guide/HomePage">arduino.cc/en/Guide/HomePage</a></p>

<p>Be sure you have Arduino version 1.6.0 or later. <strong>It is required.</strong></p>

<p>Download Arduino: <a href="http://http://arduino.cc/en/Main/Software">arduino.cc</a></p>

<p>Download the monome installer: <a href="http://monome.org/docs/begin">monome.org/docs/begin</a></p>

<p>Download the code examples here: <a href="https://github.com/monome/grid-studies-arduino/releases/latest">github.com/monome/grid-studies-arduino/releases/latest</a></p>

<h2 id="toc_2">Hardware</h2>

<p>There are innumerable versions of the Arduino hardware.</p>

<p><strong>Ardunio Due required.</strong> Other variants will not work. You can get them at the <a href="http://store.arduino.cc/product/A000062">Arduino Store</a> and at various <a href="http://arduino.cc/en/Main/Buy">distributors</a>.</p>

<p>To gain access to the USB Host capabilities, you need a strange USB cable-- micro OTG to Female A. See <a href="http://www.digikey.com/product-search/en?x=0&amp;y=0&amp;lang=en&amp;site=us&amp;keywords=839-1105-ND">Digikey 839-1105-ND</a>.</p>

<p>Grids also require a substantial amount of power to light so many LEDs-- more power than an Arduino can supply. The solution to this is to power the grid externally. We&#39;ve made a small adapter that does this, called <em>ext5v</em>. You can get one at <a href="http://market.monome.org">market.monome.org</a>.</p>

<p>The kit includes the needed OTG-A cable and a very short USB cable to make this entire setup very tidy, as seen below.</p>

<p><img src="images/grid-studies-arduino-hardware.jpg" alt=""></p>

<p>It is incredibly important to power the small adapter with 5V and nothing else. You can fry all sorts of things otherwise. The 5V DC supply is included in the kit (not shown in the photo).</p>

<h2 id="toc_3">Setup</h2>

<p>Download the MonomeHost library:</p>

<p><a href="https://github.com/monome/MonomeHost/releases/latest">github.com/monome/MonomeHost/releases/latest</a></p>

<p>Unzip the file. Launch the Arduino software.</p>

<p>Go to <code>Sketch</code> &gt; <code>Import Library</code> &gt; <code>Add Library...</code></p>

<p>Navigate to the unzipped folder of the MonomeHost library. It will be installed.</p>

<p>Finally, you&#39;ll need to select your <code>Board</code> and <code>Port</code> settings to specify the connected Arduino Due. See the screenshots below.</p>

<h2 id="toc_4"></h2>

<p><img src="images/grid-studies-arduino-board.png" alt=""></p>

<h2 id="toc_5"></h2>

<p><img src="images/grid-studies-arduino-port.png" alt=""></p>

<h2 id="toc_6"></h2>

<p>We&#39;re ready to go.</p>

<h2 id="toc_7">1. Connect</h2>

<p><em>See grid-studies-1.ino for this section.</em></p>

<p>The MonomeHost library facilitates easy connection and communication with grids. First, two headers must be included, and then we initialize our grid:</p>

<pre><code class="language-cpp">#include &lt;Usb.h&gt;  
#include &quot;MonomeController.h&quot;

USBHost usb;
MonomeController monome(usb);</code></pre>

<p>Next the <code>setup()</code> function is run, as is usual with Arduino:</p>

<pre><code class="language-cpp">void setup() { 
  monome.SetConnectCallback(&amp;ConnectCallback);
  
  Serial.begin(115200);
  Serial.print(&quot;\r\ninitialized.\r\n&quot;);
  delay(200);
}</code></pre>

<p>Here <code>SetConnectCallback()</code> assigns a function which will be called upon successful connection to a grid device.</p>

<p>After this, we set up the serial debug port and print something (to let us know we&#39;re getting started when the sketch runs.)</p>

<p>Here is the function we assigned to be called upon device connection:</p>

<pre><code class="language-cpp">void ConnectCallback(const char * name, byte cols, byte rows) {
  Serial.print(&quot;\r\nmonome device connected; type: &quot;);
  Serial.print(name);
  Serial.print(&quot; ; columns: &quot;);
  Serial.print(cols);
  Serial.print(&quot; ; rows: &quot;);
  Serial.print(rows);
  Serial.print(&quot;\r\n&quot;);
}</code></pre>

<p>It prints out a bunch of device parameters, so you know it&#39;s connected.</p>

<p>And finally the main loop:</p>

<pre><code class="language-cpp">void loop() { 
  usb.Task();
}</code></pre>

<p>That&#39;s it! Compile and upload the sketch. To actually see something happen, run the <code>Serial Monitor</code> which is in the <code>Tools</code> menu. Set the baud rate to 115200 as shown:</p>

<p><img src="images/grid-studies-arduino-serial-monitor.png" alt=""></p>

<p>You should see something similar get printed. Try resetting the hardware with the button near the USB ports on the Arduino.</p>

<h2 id="toc_8">2. Basics</h2>

<p><em>See grid-studies-2.ino for this section.</em></p>

<h3 id="toc_9">2.1 Key input</h3>

<p>Within <code>setup()</code> we assign a function to handle key presses, similar to how we handle connection events:</p>

<pre><code class="language-cpp">monome.SetGridKeyCallback(&amp;GridKeyCallback);</code></pre>

<p>And then the function itself:</p>

<pre><code class="language-cpp">void GridKeyCallback(byte x, byte y, byte z) { 
  Serial.print(&quot;\r\ngrid key: &quot;);
  Serial.print(x);
  Serial.print(&quot; , &quot;);
  Serial.print(y);
  Serial.print(&quot; : &quot;);
  Serial.print(z);</code></pre>

<p>Grid input has three parameters:</p>

<pre><code>x : horizontal position (0-15)
y : vertical position (0-7)
z : state (1 = key down, 0 = key up)</code></pre>

<p>Right now we&#39;re just printing this data out to the serial monitor. We will, of course, do more interesting things with this function in the future.</p>

<h3 id="toc_10">2.2 LED output</h3>

<p>We change the state of an LED by using the function:</p>

<pre><code class="language-cpp">monome.led_set(x, y, z);</code></pre>

<p>This changes the LED at position <code>(x,y)</code> to state <code>z</code>, where <code>z</code> is 0 to 15. 0 is off 15 is full brightness, with 14 dimmed levels in between.</p>

<p>The grid is not physically refreshed until you explicitly call:</p>

<pre><code class="language-cpp">monome.refresh();</code></pre>

<p>This way you can assemble a full grid update and refresh synchronously.</p>

<p>In our first example, we simply turn on LEDs according to key-downs, inside the <code>GridKeyCallback()</code> function:</p>

<pre><code class="language-cpp">monome.led_set(x, y, z * 15);
monome.refresh();</code></pre>

<p>Since <code>z</code> from the key input is 0 or 1, we multiply by 15 to get off and full brightness in the same position.</p>

<h2 id="toc_11">3. Further</h2>

<p>Now we&#39;ll show how basic grid applications are developed by creating a step sequencer. We will add features incrementally:</p>

<ul>
<li>Use the top six rows as toggles.</li>
<li>Generate a clock pulse to advance the playhead from left to right, one column at a time. Wrap back to 0 at the end.</li>
<li>Display the play head on &quot;position&quot; (last) row.</li>
<li>Indicate the &quot;activity&quot; row (second to last) with a low brightness.</li>
<li>Trigger an event when the playhead reads an &quot;on&quot; toggle. Our &quot;event&quot; will be to turn on the corresponding LED in the &quot;activity&quot; row.</li>
<li>Jump to playback position when key pressed in the position row.</li>
<li>Adjust playback loop with two-key gesture in position row.</li>
</ul>

<h3 id="toc_12">3.1 Toggles</h3>

<p><em>See grid-studies-3-1.ino for this step.</em></p>

<p>First we&#39;ll create a new array called <code>step</code> that can hold 6 rows worth of step data. On key input we&#39;ll look for key-down events in the top six rows:</p>

<pre><code class="language-cpp">// toggle steps
if(z == 1 &amp;&amp; y &lt; 6) {
    step[y][x] ^= 1;
    dirty = true; 
}</code></pre>

<p>If this condition is true, we toggle the corresponding position in the <code>step</code> data. Notice the addition of the <code>dirty</code> flag.</p>

<p>Inside <code>loop()</code> we check this flag. If true, it means we need to refresh the grid display.</p>

<pre><code class="language-cpp">if(dirty) {
    redraw();
    monome.refresh();
    dirty = false;
}</code></pre>

<p>We will &quot;build&quot; the LED display from scratch each time, inside of <code>redraw()</code>. Below we simply copy the <code>step</code> data to the <code>led</code> array, doing the proper multiplication by 11 in order to get almost-full brightness:</p>

<pre><code class="language-cpp">void redraw() {
    monome.led_clear();
    for(int y=0;y&lt;6;y++)
        for(int x=0;x&lt;16;x++)
            monome.led_set(x,y,step[y][x] * 11);
}</code></pre>

<p>First <code>led_clear()</code> completely clears the grid, and then we iterate through the array, copying <code>step</code> data to the grid.</p>

<p>After leaving <code>redraw()</code> we do <code>monome.refresh()</code> and then unset <code>dirty</code>.</p>

<p>That&#39;ll get us started.</p>

<h3 id="toc_13">3.2 Play</h3>

<p><em>See grid-studies-3-2.ino for this step.</em></p>

<p>Now we need a clock. We&#39;ll make a quick (read: slightly sloppy) clock using <code>millis()</code>. First a few variables:</p>

<pre><code class="language-cpp">unsigned long t = millis();
unsigned long interval = 200;</code></pre>

<p>And then inside <code>loop()</code>:</p>

<pre><code class="language-cpp">if(millis() - t &gt; interval) {
    t = millis();
    next();
}</code></pre>

<p>Each time this is called, the current time is compared to the last recorded <code>t</code> to see if it has reached <code>interval</code>. If so, we reset <code>t</code> to the current time and call <code>next()</code>, which will process the next sequence step.</p>

<p>You can change the speed by altering the value of <code>interval</code>. The value is roughly the number of milliseconds in between steps-- so smaller values will make the sequencer go faster.</p>

<p>Inside <code>next()</code> we update <code>play_position</code>:</p>

<pre><code class="language-cpp">
void next() {
  if(play_position == 15)
      play_position = 0;
  else 
      play_position++;
    
  dirty = true;
}</code></pre>

<p>This simply increments the position and wraps back to 0 once it hits the end. We set the dirty flag, as we want to redraw a play head on the grid. Shown is the updated <code>redraw()</code>:</p>

<pre><code class="language-cpp">byte highlight;
for(byte x=0;x&lt;16;x++) {
    if(x == play_position)
        highlight = 4;
    else
        highlight = 0;
 
    for(byte y=0;y&lt;6;y++)
        monome.led_set(x,y,step[y][x] * 11 + highlight);
}</code></pre>

<p>During this loop which copies steps to the grid, we check if we&#39;re updating a column that is the play position. If so, we increase the highlight value. By adding this value during the copy we&#39;ll get a nice effect of an overlaid translucent bar.</p>

<h3 id="toc_14">3.3 Triggers</h3>

<p><em>See grid-studies-3-3.ino for this step.</em></p>

<p>When the playhead advances to a new row we want something to happen which corresponds to the toggled-on rows. We&#39;ll do two things: we&#39;ll show separate visual feedback on the grid in the second-to-last (trigger) row, and we&#39;ll call a <code>trigger()</code> function that will send serial.</p>

<p>Drawing the trigger row happens entirely in the <code>redraw()</code>:</p>

<pre><code class="language-cpp">// draw trigger row and on-triggers
for(byte x=0;x&lt;16;x++)
    monome.led_set(x,6,4);
for(byte y=0;y&lt;6;y++)
    if(step[y][play_position] == 1)
        monome.led_set(y,6,15);</code></pre>

<p>First we create a dim row (level 4 is fairly dim). Then we search through the <code>step</code> array at the current play position, showing a bright indicator for each on state. This displays a sort of horizontal correlation of rows (or &quot;channels&quot;) 1-6 current state.</p>

<p>For sending serial, we create a function <code>trigger()</code> which gets passed values of activated steps. This is what we do, inside <code>next()</code> right after we change `play_position&#39;:</p>

<pre><code class="language-java">// TRIGGER SOMETHING
for(int y=0;y&lt;6;y++)
    if(step[y][play_position] == 1)
        trigger(y);</code></pre>

<p>And then <code>trigger()</code> itself:</p>

<pre><code class="language-cpp">void trigger(byte i) {
    Serial.print(i);
}</code></pre>

<p>You&#39;ll need to open Serial Monitor to see this. Compelling, yes! But this code is easily replaced with digital IO, sending MIDI, revving a motor, shooting a canon, etc.</p>

<h3 id="toc_15">3.4 Cutting</h3>

<p><em>See grid-studies-3-4.ino for this step.</em></p>

<p>We will now use the bottom row to dynamically cut the playback position. First let&#39;s add a position display to the last row, which will be inside <code>redraw()</code>:</p>

<pre><code class="language-cpp">// draw playback position
monome.led_set(play_position,7,15);</code></pre>

<p>Now we look for key presses in the last row, in the <code>GridKeyCallback()</code> function:</p>

<pre><code class="language-cpp">// toggle steps
if(z == 1 &amp;&amp; y &lt; 6) {
    step[y][x] ^= 1;
    dirty = true; 
}
// cut
else if(y == 7) {
    if(z == 1)
        cutting = true;
        next_position = x;  
    }
}</code></pre>

<p>We&#39;ve added two variables, <code>cutting</code> and <code>next_position</code>. Check out the changed code inside <code>next()</code> where we advance the play head:</p>

<pre><code class="language-cpp">if(cutting)
    play_position = next_position;
else if(play_position == 15)
    play_position = 0;
else 
    play_position++;
    
cutting = false;</code></pre>

<p>Now, when pressing keys on the bottom row it will cue the next position to be played. Note that we set <code>cutting = false</code> after each cycle so that each press only affects the timer once.</p>

<h3 id="toc_16">3.5 Loop</h3>

<p>Lastly, we&#39;ll implement setting the loop start and end points with a two-press gesture: pressing and holding the start point, and pressing an end point while still holding the first key. We&#39;ll need to add a variable to count keys held, one to track the last key pressed, and variables to store the loop positions.</p>

<pre><code class="language-java">byte keys_held, key_last;
byte loop_start, loop_end = 15;</code></pre>

<p>We set <code>loop_end</code> by default to the maximum length (15).</p>

<p>We count keys held on the bottom row thusly:</p>

<pre><code class="language-cpp">keys_held = keys_held + (z*2) - 1;</code></pre>

<p>By multiplying <code>z</code> by 2 and then subtracting one, we add one on a key down and subtract one on a key up.</p>

<p>We&#39;ll then use the <code>keys_held</code> counter to do different actions:</p>

<pre><code class="language-cpp">// cut and loop
else if(y == 7) {
    // track number of keys held
    keys_held = keys_held + (z*2) - 1;
        
    // cut
    if(z == 1 &amp;&amp; keys_held == 1) {
        cutting = true;
        next_position = x;
        key_last = x;
    }
    // set loop points
    else if(z == 1 &amp;&amp; keys_held == 2) {
        loop_start = key_last;
        loop_end = x;
    }
}</code></pre>

<p>We then modify the position change code in <code>next()</code>:</p>

<pre><code class="language-cpp">if(cutting)
    play_position = next_position;
else if(play_position == 15)
    play_position = 0;
else if(play_position == loop_end)
    play_position = loop_start;
else 
    play_position++;</code></pre>

<p>Done!</p>

<h2 id="toc_17">Closing</h2>

<h3 id="toc_18">Suggested Excercises</h3>

<ul>
<li>&quot;Record&quot; keypresses in the &quot;trigger&quot; row to the toggle matrix.</li>
<li>Display the loop range on the bottom row of the grid.</li>
<li>Use the rightmost key in the &quot;trigger&quot; row as an &quot;alt&quot; key.

<ul>
<li>If &quot;alt&quot; is held while pressing a toggle, clear the entire row.</li>
<li>If &quot;alt&quot; is held while pressing the play row, reverse the direction of play.</li>
</ul></li>
</ul>

<h2 id="toc_19">Credits</h2>

<p><em>Arduino</em> was founded by Massimo Banzi, David Cuartielles, Tom Igoe, Gianluca Martino, and David Mellis. <a href="http://arduino.cc">Arduino</a>.</p>

<p><em>MonomeHost</em> was written by and is maintained by <a href="http://catfact.net">Ezra Buchla</a>.</p>

<p>This tutorial was created by <a href="http://nnnnnnnn.org">Brian Crabtree</a> for <a href="monome.org">monome.org</a>.</p>

<p>Contributions welcome. Submit a pull request to <a href="https://github.com/monome/grid-studies-arduino">github.com/monome/grid-studies-arduino</a> or e-mail <a href="mailto:info@monome.org">info@monome.org</a>.</p>

<script type="text/javascript">
self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{};var Prism=function(){var e=/\blang(?:uage)?-(?!\*)(\w+)\b/i,t=self.Prism={util:{encode:function(e){return e instanceof n?new n(e.type,t.util.encode(e.content),e.alias):"Array"===t.util.type(e)?e.map(t.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},clone:function(e){var n=t.util.type(e);switch(n){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=t.util.clone(e[r]));return a;case"Array":return e.map(function(e){return t.util.clone(e)})}return e}},languages:{extend:function(e,n){var a=t.util.clone(t.languages[e]);for(var r in n)a[r]=n[r];return a},insertBefore:function(e,n,a,r){r=r||t.languages;var i=r[e];if(2==arguments.length){a=arguments[1];for(var l in a)a.hasOwnProperty(l)&&(i[l]=a[l]);return i}var o={};for(var s in i)if(i.hasOwnProperty(s)){if(s==n)for(var l in a)a.hasOwnProperty(l)&&(o[l]=a[l]);o[s]=i[s]}return t.languages.DFS(t.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=o)}),r[e]=o},DFS:function(e,n,a){for(var r in e)e.hasOwnProperty(r)&&(n.call(e,r,e[r],a||r),"Object"===t.util.type(e[r])?t.languages.DFS(e[r],n):"Array"===t.util.type(e[r])&&t.languages.DFS(e[r],n,r))}},highlightAll:function(e,n){for(var a,r=document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'),i=0;a=r[i++];)t.highlightElement(a,e===!0,n)},highlightElement:function(a,r,i){for(var l,o,s=a;s&&!e.test(s.className);)s=s.parentNode;if(s&&(l=(s.className.match(e)||[,""])[1],o=t.languages[l]),o){a.className=a.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,s=a.parentNode,/pre/i.test(s.nodeName)&&(s.className=s.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var g=a.textContent;if(g){g=g.replace(/^(?:\r?\n|\r)/,"");var u={element:a,language:l,grammar:o,code:g};if(t.hooks.run("before-highlight",u),r&&self.Worker){var c=new Worker(t.filename);c.onmessage=function(e){u.highlightedCode=n.stringify(JSON.parse(e.data),l),t.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,i&&i.call(u.element),t.hooks.run("after-highlight",u)},c.postMessage(JSON.stringify({language:u.language,code:u.code}))}else u.highlightedCode=t.highlight(u.code,u.grammar,u.language),t.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,i&&i.call(a),t.hooks.run("after-highlight",u)}}},highlight:function(e,a,r){var i=t.tokenize(e,a);return n.stringify(t.util.encode(i),r)},tokenize:function(e,n){var a=t.Token,r=[e],i=n.rest;if(i){for(var l in i)n[l]=i[l];delete n.rest}e:for(var l in n)if(n.hasOwnProperty(l)&&n[l]){var o=n[l];o="Array"===t.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var g=o[s],u=g.inside,c=!!g.lookbehind,f=0,h=g.alias;g=g.pattern||g;for(var p=0;p<r.length;p++){var d=r[p];if(r.length>e.length)break e;if(!(d instanceof a)){g.lastIndex=0;var m=g.exec(d);if(m){c&&(f=m[1].length);var y=m.index-1+f,m=m[0].slice(f),v=m.length,k=y+v,b=d.slice(0,y+1),w=d.slice(k+1),O=[p,1];b&&O.push(b);var N=new a(l,u?t.tokenize(m,u):m,h);O.push(N),w&&O.push(w),Array.prototype.splice.apply(r,O)}}}}}return r},hooks:{all:{},add:function(e,n){var a=t.hooks.all;a[e]=a[e]||[],a[e].push(n)},run:function(e,n){var a=t.hooks.all[e];if(a&&a.length)for(var r,i=0;r=a[i++];)r(n)}}},n=t.Token=function(e,t,n){this.type=e,this.content=t,this.alias=n};if(n.stringify=function(e,a,r){if("string"==typeof e)return e;if("[object Array]"==Object.prototype.toString.call(e))return e.map(function(t){return n.stringify(t,a,e)}).join("");var i={type:e.type,content:n.stringify(e.content,a,r),tag:"span",classes:["token",e.type],attributes:{},language:a,parent:r};if("comment"==i.type&&(i.attributes.spellcheck="true"),e.alias){var l="Array"===t.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(i.classes,l)}t.hooks.run("wrap",i);var o="";for(var s in i.attributes)o+=s+'="'+(i.attributes[s]||"")+'"';return"<"+i.tag+' class="'+i.classes.join(" ")+'" '+o+">"+i.content+"</"+i.tag+">"},!self.document)return self.addEventListener?(self.addEventListener("message",function(e){var n=JSON.parse(e.data),a=n.language,r=n.code;self.postMessage(JSON.stringify(t.util.encode(t.tokenize(r,t.languages[a])))),self.close()},!1),self.Prism):self.Prism;var a=document.getElementsByTagName("script");return a=a[a.length-1],a&&(t.filename=a.src,document.addEventListener&&!a.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",t.highlightAll)),self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism);
</script>
<script type="text/javascript">
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//g,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*?(\r?\n|$)/g,lookbehind:!0}],string:/("|')(\\\n|\\?.)*?\1/g,"class-name":{pattern:/((?:(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/gi,lookbehind:!0,inside:{punctuation:/(\.|\\)/}},keyword:/\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/g,"boolean":/\b(true|false)\b/g,"function":{pattern:/[a-z0-9_]+\(/gi,inside:{punctuation:/\(/}},number:/\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?)\b/g,operator:/[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\|?\||\?|\*|\/|~|\^|%/g,ignore:/&(lt|gt|amp);/gi,punctuation:/[{}[\];(),.:]/g};
</script>
<script type="text/javascript">
Prism.languages.c=Prism.languages.extend("clike",{string:/("|')([^\n\\\1]|\\.|\\\r*\n)*?\1/g,keyword:/\b(asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/g,operator:/[-+]{1,2}|!=?|<{1,2}=?|>{1,2}=?|\->|={1,2}|\^|~|%|&{1,2}|\|?\||\?|\*|\//g}),Prism.languages.insertBefore("c","string",{property:{pattern:/((^|\n)\s*)#\s*[a-z]+([^\n\\]|\\.|\\\r*\n)*/gi,lookbehind:!0,inside:{string:{pattern:/(#\s*include\s*)(<.+?>|("|')(\\?.)+?\3)/g,lookbehind:!0}}}}),delete Prism.languages.c["class-name"],delete Prism.languages.c["boolean"];
</script>
<script type="text/javascript">
Prism.languages.cpp=Prism.languages.extend("c",{keyword:/\b(alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|delete\[\]|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|long|mutable|namespace|new|new\[\]|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/g,"boolean":/\b(true|false)\b/g,operator:/[-+]{1,2}|!=?|<{1,2}=?|>{1,2}=?|\->|:{1,2}|={1,2}|\^|~|%|&{1,2}|\|?\||\?|\*|\/|\b(and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/g}),Prism.languages.insertBefore("cpp","keyword",{"class-name":{pattern:/(class\s+)[a-z0-9_]+/gi,lookbehind:!0}});
</script>
<script type="text/javascript">
Prism.languages.java=Prism.languages.extend("clike",{keyword:/\b(abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/g,number:/\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp\-]+\b|\b\d*\.?\d+[e]?[\d]*[df]\b|\b\d*\.?\d+\b/gi,operator:{pattern:/(^|[^\.])(?:\+=|\+\+?|-=|--?|!=?|<{1,2}=?|>{1,3}=?|==?|&=|&&?|\|=|\|\|?|\?|\*=?|\/=?|%=?|\^=?|:|~)/gm,lookbehind:!0}});
</script>
</body>

</html>
